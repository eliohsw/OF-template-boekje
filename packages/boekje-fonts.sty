\NeedsTeXFormat{LaTeX2e}
\ProvidesPackage{boekje-fonts}[2026/01/07 v0.6.4 Minimal Fonts setup]

\RequirePackage{iftex}
\ifPDFTeX
  \PackageError{boekje-fonts}{This package requires XeLaTeX or LuaLaTeX}{%
    Use \string\xelatex\space or \string\lualatex.}
\fi

\RequirePackage[no-math]{fontspec}
\defaultfontfeatures{Ligatures=TeX, Scale=MatchUppercase}
\defaultfontfeatures[CJK]{Scale=MatchLowercase}

% ========================================================================
% CJK support
%   XeLaTeX: use xeCJK
%   LuaLaTeX: xeCJK is not supported; provide clear stubs

\ifXeTeX
  \RequirePackage{xeCJK}
\else
  \newcommand\setCJKmainfont[2][]{%
    \PackageError{boekje-fonts}{CJK mode requires XeLaTeX (xeCJK)}{%
      You compiled with LuaLaTeX. Switch to XeLaTeX, or use a LuaLaTeX CJK
      solution (e.g. luatexja/ctex) and adapt this package accordingly.}%
  }
  \newcommand\setCJKsansfont[2][]{\setCJKmainfont[#1]{#2}}
  \newcommand\setCJKmonofont[2][]{\setCJKmainfont[#1]{#2}}
\fi

% ========================================================================
% Convenience font-switching commands (only define if font exists)

\IfFontExistsTF{Arial}
  {\newfontfamily\Arial{Arial}}
  {\providecommand\Arial{\normalfont}}

\IfFontExistsTF{Bebas Neue}
  {\newfontfamily\BebasNeue[Scale=MatchUppercase]{Bebas Neue}}
  {\providecommand\BebasNeue{\normalfont}}

\IfFontExistsTF{TeX Gyre Heros}
  {\newfontfamily\TeXGyreHeros{TeX Gyre Heros}}
  {\providecommand\TeXGyreHeros{\normalfont}}

\IfFontExistsTF{Times New Roman}
  {\newfontfamily\TimesNewRoman{Times New Roman}}
  {\providecommand\TimesNewRoman{\normalfont}}

\ifXeTeX
  \xeCJKsetup{
    CJKmath=true,
    PunctStyle=kaiming,
    RubberPunctSkip=true
  }
\fi

% ========================================================================
% Font fallback helper
%
%   \SetFontFromList[<mode>]{<family>}{<font1, font2, ...>}
%
% - <family> : main | sans | mono
% - <mode>   : (empty) uses \setmainfont/\setsansfont/\setmonofont
%              CJK     uses \setCJKmainfont/\setCJKsansfont/\setCJKmonofont
%
% For each candidate font in the list, the first one that exists is selected.
% If none exist, the corresponding default is restored.
%
% Whitespace note:
%   Items are trimmed on both ends; empty items are ignored.

\RequirePackage{xparse}
\ExplSyntaxOn

% ------------------------------------------------------------------------
% Debug toggle (prints probing/selection decisions to the .log/terminal)
%   Usage (preamble):
%     \SetFontsDebugOn
%     \SetFontsDebugOff
\bool_new:N \g__setfonts_debug_bool
\cs_new_protected:Npn \SetFontsDebugOn  { \bool_gset_true:N  \g__setfonts_debug_bool }
\cs_new_protected:Npn \SetFontsDebugOff { \bool_gset_false:N \g__setfonts_debug_bool }

% Save defaults at package load so we can restore later.
\tl_new:N \g__setfonts_rmdefault_tl
\tl_new:N \g__setfonts_sfdefault_tl
\tl_new:N \g__setfonts_ttdefault_tl
\tl_new:N \g__setfonts_CJKrmdefault_tl
\tl_new:N \g__setfonts_CJKsfdefault_tl
\tl_new:N \g__setfonts_CJKttdefault_tl

\cs_new_protected:Npn \__setfonts_store_defaults:
  {
    \tl_gset:Nx \g__setfonts_rmdefault_tl { \rmdefault }
    \tl_gset:Nx \g__setfonts_sfdefault_tl { \sfdefault }
    \tl_gset:Nx \g__setfonts_ttdefault_tl { \ttdefault }
    \cs_if_exist:NT \CJKrmdefault
      { \tl_gset:Nx \g__setfonts_CJKrmdefault_tl { \CJKrmdefault } }
    \cs_if_exist:NT \CJKsfdefault
      { \tl_gset:Nx \g__setfonts_CJKsfdefault_tl { \CJKsfdefault } }
    \cs_if_exist:NT \CJKttdefault
      { \tl_gset:Nx \g__setfonts_CJKttdefault_tl { \CJKttdefault } }
  }
\__setfonts_store_defaults:

% ------------------------------------------------------------------------
% CJK family naming strategy
%
% xeCJK warns when redefining an existing CJKfamily. To avoid that noise:
% - Every time we define a CJK main/sans/mono font, we first assign a fresh,
%   unique family name to \CJKrmdefault/\CJKsfdefault/\CJKttdefault.
% - Then \setCJK...font defines that *new* family, so no "redefining" warning.
%
% We also only auto-fill CJK sans/mono from the chosen CJK main font if the
% user hasn't explicitly set them via this package.

\int_new:N \g__setfonts_CJKrm_int
\int_new:N \g__setfonts_CJKsf_int
\int_new:N \g__setfonts_CJKtt_int

\bool_new:N \g__setfonts_CJKsf_user_bool
\bool_new:N \g__setfonts_CJKtt_user_bool

% Call a font setter with per-font options.
%   #1 = setter (e.g., \setmainfont)
%   #2 = options (no outer brackets); may be blank
%   #3 = font name
%
% IMPORTANT: no space is inserted before '['; otherwise LaTeX optional-arg
% detection would fail.
\cs_new_protected:Npn \__setfonts_set_font:Nnn #1 #2 #3
  {
    \tl_if_blank:nTF {#2}
      {#1{#3}}
      {#1[#2]{#3}}
  }

\cs_new_protected:Npn \__setfonts_cjk_set_family:nnn #1 #2 #3
  {
    \str_case:nnF {#1}
      {
        {main}{
          \int_gincr:N \g__setfonts_CJKrm_int
          \cs_set:Npx \CJKrmdefault { setfonts-CJKrm-\int_use:N \g__setfonts_CJKrm_int }
          \__setfonts_set_font:Nnn \setCJKmainfont {#2} {#3}

          % Ensure CJK sans/mono exist to avoid xeCJK "Unknown CJK family" warnings,
          % but do not override a user choice.
          \bool_if:NF \g__setfonts_CJKsf_user_bool
            {
              \int_gincr:N \g__setfonts_CJKsf_int
              \cs_set:Npx \CJKsfdefault { setfonts-CJKsf-\int_use:N \g__setfonts_CJKsf_int }
              \__setfonts_set_font:Nnn \setCJKsansfont {#2} {#3}
            }
          \bool_if:NF \g__setfonts_CJKtt_user_bool
            {
              \int_gincr:N \g__setfonts_CJKtt_int
              \cs_set:Npx \CJKttdefault { setfonts-CJKtt-\int_use:N \g__setfonts_CJKtt_int }
              \__setfonts_set_font:Nnn \setCJKmonofont {#2} {#3}
            }
        }
        {sans}{
          \int_gincr:N \g__setfonts_CJKsf_int
          \cs_set:Npx \CJKsfdefault { setfonts-CJKsf-\int_use:N \g__setfonts_CJKsf_int }
          \__setfonts_set_font:Nnn \setCJKsansfont {#2} {#3}
          \bool_gset_true:N \g__setfonts_CJKsf_user_bool
        }
        {mono}{
          \int_gincr:N \g__setfonts_CJKtt_int
          \cs_set:Npx \CJKttdefault { setfonts-CJKtt-\int_use:N \g__setfonts_CJKtt_int }
          \__setfonts_set_font:Nnn \setCJKmonofont {#2} {#3}
          \bool_gset_true:N \g__setfonts_CJKtt_user_bool
        }
      }
      { \PackageError{boekje-fonts}{Unknown font family `#1'}{Use main, sans, or mono.} }
  }

% ------------------------------------------------------------------------
% Restore defaults (only for the requested family/mode).
\cs_new_protected:Npn \__setfonts_restore_defaults:nn #1 #2
  {
    \tl_if_eq:nnTF {#1} {CJK}
      {
        \str_case:nnF {#2}
          {
            {main}{\cs_if_exist:NT \CJKrmdefault {\cs_set:Npn \CJKrmdefault {\g__setfonts_CJKrmdefault_tl}}}
            {sans}{\cs_if_exist:NT \CJKsfdefault {\cs_set:Npn \CJKsfdefault {\g__setfonts_CJKsfdefault_tl}}}
            {mono}{\cs_if_exist:NT \CJKttdefault {\cs_set:Npn \CJKttdefault {\g__setfonts_CJKttdefault_tl}}}
          }
          {\PackageError{boekje-fonts}{Unknown font family `#2'}{Use main, sans, or mono.}}

        % Reset user-choice tracking when restoring.
        \bool_gset_false:N \g__setfonts_CJKsf_user_bool
        \bool_gset_false:N \g__setfonts_CJKtt_user_bool
        \normalfont
      }
      {
        \str_case:nnF {#2}
          {
            {main}{\cs_set:Npn \rmdefault {\g__setfonts_rmdefault_tl}}
            {sans}{\cs_set:Npn \sfdefault {\g__setfonts_sfdefault_tl}}
            {mono}{\cs_set:Npn \ttdefault {\g__setfonts_ttdefault_tl}}
          }
          {\PackageError{boekje-fonts}{Unknown font family `#2'}{Use main, sans, or mono.}}
        \normalfont
      }
  }

% Apply chosen font (dispatches to the right setter).
%
% #1 mode  : (empty) | CJK
% #2 family: main | sans | mono
% #3 opts  : options passed to \set...font (without surrounding brackets)
% #4 font  : font name
\cs_new_protected:Npn \__setfonts_apply:nnnn #1 #2 #3 #4
  {
    \tl_if_eq:nnTF {#1} {CJK}
      { \__setfonts_cjk_set_family:nnn {#2} {#3} {#4} }
      {
        \str_case:nnF {#2}
          {
            {main}{\__setfonts_set_font:Nnn \setmainfont {#3} {#4}}
            {sans}{\__setfonts_set_font:Nnn \setsansfont {#3} {#4}}
            {mono}{\__setfonts_set_font:Nnn \setmonofont {#3} {#4}}
          }
          {\PackageError{boekje-fonts}{Unknown font family `#2'}{Use main, sans, or mono.}}
      }
  }

% ------------------------------------------------------------------------
% Parse a list item like:
%   Font Name
%   Font Name[<options>]
%
% into two tls:
%   \l__setfonts_fontname_tl
%   \l__setfonts_fontopts_tl   (no outer brackets)
\tl_new:N   \l__setfonts_fontname_tl
\tl_new:N   \l__setfonts_fontopts_tl
\bool_new:N \l__setfonts_inopts_bool
\int_new:N  \l__setfonts_opts_depth_int  % square-bracket nesting inside per-font options
\int_new:N  \l__setfonts_opts_brace_int  % curly-brace nesting inside per-font options

\cs_new_protected:Npn \__setfonts_parse_candidate:n #1
  {
    \tl_clear:N \l__setfonts_fontname_tl
    \tl_clear:N \l__setfonts_fontopts_tl
    \bool_set_false:N \l__setfonts_inopts_bool
    \int_zero:N \l__setfonts_opts_depth_int
    \int_zero:N \l__setfonts_opts_brace_int

    % IMPORTANT: We use \tl_analysis_map_inline:nn (not \tl_map_inline:nn)
    % so that literal spaces in font names (e.g. "Times New Roman") are
    % preserved.
    %
    % We also treat square brackets inside curly braces as ordinary content,
    % so complex key values like FontFace={sb}{n}{...} do not confuse the
    % outer [...] option parsing.
    \tl_analysis_map_inline:nn {#1}
      {
        \bool_if:NTF \l__setfonts_inopts_bool
          {
            % --- Inside the per-font option bracket [...]
            \int_compare:nNnTF {##2} = { 123 } % {
              {
                \int_incr:N \l__setfonts_opts_brace_int
                \tl_put_right:Nn \l__setfonts_fontopts_tl {##1}
              }
              {
                \int_compare:nNnTF {##2} = { 125 } % }
                  {
                    \int_compare:nNnT { \l__setfonts_opts_brace_int } > { 0 }
                      { \int_decr:N \l__setfonts_opts_brace_int }
                    \tl_put_right:Nn \l__setfonts_fontopts_tl {##1}
                  }
                  {
                    % Only treat [ and ] as nesting delimiters when we are
                    % not inside {...}. This prevents stray ']' inside key
                    % values from prematurely closing the outer option list.
                    \int_compare:nNnTF {##2} = { 91 } % [
                      {
                        \int_compare:nNnTF { \l__setfonts_opts_brace_int } = { 0 }
                          {
                            \int_incr:N \l__setfonts_opts_depth_int
                            \tl_put_right:Nn \l__setfonts_fontopts_tl {##1}
                          }
                          { \tl_put_right:Nn \l__setfonts_fontopts_tl {##1} }
                      }
                      {
                        \int_compare:nNnTF {##2} = { 93 } % ]
                          {
                            \int_compare:nNnTF { \l__setfonts_opts_brace_int } = { 0 }
                              {
                                \int_decr:N \l__setfonts_opts_depth_int
                                \int_compare:nNnTF { \l__setfonts_opts_depth_int } = { 0 }
                                  { \bool_set_false:N \l__setfonts_inopts_bool }
                                  { \tl_put_right:Nn \l__setfonts_fontopts_tl {##1} }
                              }
                              { \tl_put_right:Nn \l__setfonts_fontopts_tl {##1} }
                          }
                          { \tl_put_right:Nn \l__setfonts_fontopts_tl {##1} }
                      }
                  }
              }
          }
          {
            % --- Not in options: build the font name until the first '['
            \int_compare:nNnTF {##2} = { 91 } % [
              {
                \bool_set_true:N \l__setfonts_inopts_bool
                \int_set:Nn \l__setfonts_opts_depth_int { 1 }
                \int_zero:N \l__setfonts_opts_brace_int
              }
              { \tl_put_right:Nn \l__setfonts_fontname_tl {##1} }
          }
      }

    % Unwrap the \exp_not:n{...} tokens produced by \tl_analysis_map_inline:nn
    % so downstream trimming + fontspec lookup see real spaces/braces.
    \tl_set:Nx \l__setfonts_fontname_tl { \l__setfonts_fontname_tl }
    \tl_set:Nx \l__setfonts_fontopts_tl { \l__setfonts_fontopts_tl }

    \tl_trim_spaces:N \l__setfonts_fontname_tl
    \tl_trim_spaces:N \l__setfonts_fontopts_tl
  }

% ------------------------------------------------------------------------
% Split a comma-separated list into items, but do NOT split at commas inside
% [...] option brackets.
\seq_new:N \l__setfonts_candidates_seq
\tl_new:N  \l__setfonts_current_item_tl
\int_new:N \l__setfonts_list_depth_int
\int_new:N \l__setfonts_list_brace_int

\cs_new_protected:Npn \__setfonts_seq_put_trimmed:NN #1 #2
  {
    \tl_set:Nn \l_tmpa_tl { \tl_use:N #2 }
    \tl_set:Nx \l_tmpa_tl { \l_tmpa_tl }
    \tl_trim_spaces:N \l_tmpa_tl
    \tl_if_blank:VF \l_tmpa_tl { \seq_put_right:NV #1 \l_tmpa_tl }
  }

\cs_new_protected:Npn \__setfonts_split_candidates:nN #1 #2
  {
    \seq_clear:N #2
    \tl_clear:N \l__setfonts_current_item_tl
    \int_zero:N \l__setfonts_list_depth_int
    \int_zero:N \l__setfonts_list_brace_int

    % IMPORTANT: Use \tl_analysis_map_inline:nn to preserve literal spaces.
    % We ignore commas while inside [...] options, and we ignore any square
    % brackets that appear *inside* {...} groups within those options.
    \tl_analysis_map_inline:nn {#1}
      {
        % Track curly-brace nesting only when we're already inside [...].
        \int_compare:nNnT { \l__setfonts_list_depth_int } > { 0 }
          {
            \int_compare:nNnTF {##2} = { 123 } % {
              { \int_incr:N \l__setfonts_list_brace_int }
              {
                \int_compare:nNnTF {##2} = { 125 } % }
                  {
                    \int_compare:nNnT { \l__setfonts_list_brace_int } > { 0 }
                      { \int_decr:N \l__setfonts_list_brace_int }
                  }
                  { }
              }
          }

        \int_compare:nNnTF {##2} = { 44 } % comma
          {
            \int_compare:nNnTF { \l__setfonts_list_depth_int } = { 0 }
              {
                \__setfonts_seq_put_trimmed:NN #2 \l__setfonts_current_item_tl
                \tl_clear:N \l__setfonts_current_item_tl
              }
              { \tl_put_right:Nn \l__setfonts_current_item_tl {##1} }
          }
          {
            \int_compare:nNnTF {##2} = { 91 } % [
              {
                \int_compare:nNnTF { \l__setfonts_list_brace_int } = { 0 }
                  { \int_incr:N \l__setfonts_list_depth_int }
                  { }
                \tl_put_right:Nn \l__setfonts_current_item_tl {##1}
              }
              {
                \int_compare:nNnTF {##2} = { 93 } % ]
                  {
                    \int_compare:nNnTF { \l__setfonts_list_brace_int } = { 0 }
                      {
                        \int_compare:nNnT { \l__setfonts_list_depth_int } > { 0 }
                          { \int_decr:N \l__setfonts_list_depth_int }
                      }
                      { }
                    \tl_put_right:Nn \l__setfonts_current_item_tl {##1}
                  }
                  { \tl_put_right:Nn \l__setfonts_current_item_tl {##1} }
              }
          }
      }

    \__setfonts_seq_put_trimmed:NN #2 \l__setfonts_current_item_tl
  }

% ------------------------------------------------------------------------
% Main selector: pick first existing font from a list.
\bool_new:N \l__setfonts_found_bool

% ------------------------------------------------------------------------
% Option-aware existence test
%
% We *must* include candidate options in the existence test; otherwise fonts
% that are only accessible via Path/Extension/FontIndex/Renderer/etc. will be
% falsely reported as missing and skipped.
%
%   #1 = fontspec options (may be blank)
%   #2 = font name (already trimmed)
%
% This relies on fontspec internals, but keeps the test non-fatal.
\prg_new_conditional:Nnn \__setfonts_fontspec_if_exist:nn {TF,T,F}
  {
    \group_begin:
      \__fontspec_init:

      % Keep fontspec's internal state consistent with an actual \set...font call.
      \tl_clear:N \l__fontspec_family_label_tl

      \__fontspec_sanitise_fontname:Nn \l_fontspec_fontname_tl      {#2}
      \__fontspec_sanitise_fontname:Nn \l__fontspec_fontname_up_tl   {#2}
      \__fontspec_sanitise_fontname:Nn \l__fontspec_basename_tl      {#2}

      % If the font name itself looks like a filename (e.g. *.otf), switch to
      % file-loading mode (Path may still be set via options below).
      \__fontspec_if_detect_external:nT {#2}
        { \keys_set:nn {fontspec-preparse-external} {Path} }

      % Read options (including Path/Extension/FontIndex/Renderer/...)
      \keys_set_known:nn {fontspec-preparse-cfg} {#1}
      \__fontspec_extract_all_features:n {#1}
      \__fontspec_preparse_features:

      \__fontspec_primitive_font_if_exist:nTF
        { \__fontspec_construct_font_call:nn { \l__fontspec_fontname_up_tl } {} }
        { \group_end: \prg_return_true: }
        { \group_end: \prg_return_false: }
  }

\cs_new_protected:Npn \__setfonts_select_from_list:nnn #1 #2 #3
  {
    \bool_set_false:N \l__setfonts_found_bool
    \__setfonts_split_candidates:nN {#3} \l__setfonts_candidates_seq

    \seq_map_inline:Nn \l__setfonts_candidates_seq
      {
        \__setfonts_parse_candidate:n {##1}
        \tl_if_blank:VF \l__setfonts_fontname_tl
          {
            \bool_if:NT \g__setfonts_debug_bool
              {
                \iow_term:x
                  {
                    boekje-fonts:~probe~mode=
                      \tl_if_blank:nTF {#1} {Latin} {#1}
                    ,~family=#2,
                    ~font='\tl_to_str:N \l__setfonts_fontname_tl',
                    ~opts='\tl_to_str:N \l__setfonts_fontopts_tl'
                  }
              }

            \__setfonts_fontspec_if_exist:nnTF
              { \tl_use:N \l__setfonts_fontopts_tl }
              { \tl_use:N \l__setfonts_fontname_tl }
              {
                \bool_if:NT \g__setfonts_debug_bool
                  {
                    \iow_term:x
                      {
                        boekje-fonts:~select~'\tl_to_str:N \l__setfonts_fontname_tl'
                      }
                  }

                \__setfonts_apply:nnnn
                  {#1}
                  {#2}
                  {\tl_use:N \l__setfonts_fontopts_tl}
                  {\tl_use:N \l__setfonts_fontname_tl}
                \bool_set_true:N \l__setfonts_found_bool
                \seq_map_break:
              }
              {
                \bool_if:NT \g__setfonts_debug_bool
                  {
                    \iow_term:x
                      {
                        boekje-fonts:~miss~'\tl_to_str:N \l__setfonts_fontname_tl'
                      }
                  }
              }
          }
      }

    \bool_if:NF \l__setfonts_found_bool
      { \__setfonts_restore_defaults:nn {#1} {#2} }
  }

% Public command
%   \SetFontFromList{main|sans|mono}{...}
%   \SetFontFromList[CJK]{main|sans|mono}{...}
\NewDocumentCommand \SetFontFromList { o m m }
  {
    \IfNoValueTF{#1}
      { \__setfonts_select_from_list:nnn {} {#2} {#3} }
      {
        \tl_set:Nn \l_tmpa_tl {#1}
        \tl_trim_spaces:N \l_tmpa_tl
        \tl_if_blank:nTF { \tl_use:N \l_tmpa_tl }
          { \__setfonts_select_from_list:nnn {} {#2} {#3} }
          {
            % Normalize mode: detokenize + uppercase, so [cjk] works.
            \tl_set:Nx \l_tmpa_tl { \tl_upper_case:n { \tl_to_str:N \l_tmpa_tl } }
            \str_if_eq:VnTF \l_tmpa_tl {CJK}
              { \__setfonts_select_from_list:nnn {CJK} {#2} {#3} }
              { \PackageError{boekje-fonts}{Unknown mode `#1'}{Only [CJK] is supported.} }
          }
      }
  }

\ExplSyntaxOff


% ========================================================================
% Semi-bold font series (if available)

\makeatletter
\@ifundefined{sbseries}{%
  \DeclareRobustCommand{\sbseries}{%
    \ifcsname \f@encoding/\f@family/sb/\f@shape\endcsname
      \fontseries{sb}\selectfont
    \else
      \bfseries
    \fi
  }%
}{}

\@ifundefined{textsb}{%
  \DeclareTextFontCommand{\textsb}{\sbseries}%
}{}
\makeatother